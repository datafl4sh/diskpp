#pragma once
#include <optional>

/* The mesh can come from the internal meshers or from a file */
enum class mesh_source {
    internal,
    file,
    invalid,
};

/* Type of mesh generated by the internal meshers */
enum class internal_mesh_type {
    triangles,
    quadrangles,
    hexagons,
    tetrahedra,
    invalid,
};

/* All the mesh parameters collected from the user */
struct mesh_parameters {
    mesh_source         source;
    internal_mesh_type  type;
    std::string         filename;
    size_t              level;
};


/* HHO variant in use */
enum class hho_variant {
    mixed_order_low,
    equal_order,
    mixed_order_high,
};

/* Boundary condition type */
enum class boundary_type {
    not_a_boundary,
    undefined,
    invalid,
    dirichlet,
    neumann,
    robin,
    jump,
};

/* Boundary condition parameters */
template<typename T>
struct boundary_condition_descriptor {
    boundary_type       type;
    std::optional<T>    value;
    size_t              number;
    bool                internal;
};

#include "poisson_assembler.h"

/* This concept is a workaround to make the code compile under
 * gcc13+.
 * The code compiles fine under clang and gcc 12.3.0, however
 * starting from gcc 13, gcc tries to instantiate Mesh using
 * complete nonsensical types, including stuff from the STL.
 * I have no idea of what is happening, but it definitely looks
 * like some nasty GCC bug. */
template<typename Mesh>
concept some_kind_of_mesh = requires {
    typename Mesh::cell_type;
    typename Mesh::face_type;
    Mesh::dimension;
};

template<some_kind_of_mesh Mesh>
struct hho_poisson_solver_state
{
    using mesh_type = Mesh;
    using cell_type = typename Mesh::cell_type;
    using face_type = typename Mesh::face_type;
    using scalar_type = typename Mesh::coordinate_type;
    using assembler_type = hho_assembler<Mesh>;
    using vector_type = disk::dynamic_vector<scalar_type>;
    using bndcond_type = boundary_condition_descriptor<scalar_type>;

    mesh_type                   msh;
    assembler_type              assm;
    vector_type                 sol;
    vector_type                 sol_full;

    std::vector<bndcond_type>   boundary_info;

    disk::hho_degree_info       hdi;
    hho_variant                 variant;
    bool                        use_stabfree;
    bool                        use_dt_stab;

    std::vector<double>         recdegs;

    double                      A_norm;
    double                      AS_norm;
};


